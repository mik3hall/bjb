package org.bjb;import java.io.*;import java.util.HashMap;				public class EV {	private static HashMap[] evs = null;	// HashMap index for different deck rule combinations	private final static int EV1DH17 = 0,					 		 EV1DS17 = 1,					 		 EV2DH17 = 2,					 		 EV2DS17 = 3,					 		 EV4DH17 = 4,					 		 EV4DS17 = 5,					 		 EV6DH17 = 6,					 		 EV6DS17 = 7,					 		 EV8DH17 = 8,					 		 EV8DS17 = 9;		public EV() {		if (evs == null) {			try {				InputStream is = EV.class.getResourceAsStream("ev.ser");				ObjectInputStream ois = new ObjectInputStream(is);				evs = (HashMap[])ois.readObject();			}			catch (IOException ioex) { ioex.printStackTrace(); }			catch (ClassNotFoundException cnfe) { cnfe.printStackTrace(); }		}	}		String[] getEV(Deck d,Hand playersHand,Card dealersUp,boolean h17) {		if (evs == null) new EV();		// init if not already done		String key = getKey(playersHand,dealersUp);		if (d.decksNUM == 1) {			if (h17) return (String[])evs[EV1DH17].get(key);			else return (String[])evs[EV1DS17].get(key);		}		else if (d.decksNUM == 2) {			if (h17) return (String[])evs[EV2DH17].get(key);			else return (String[])evs[EV2DS17].get(key);		}		else if (d.decksNUM == 4) {			if (h17) return (String[])evs[EV2DH17].get(key);			else return (String[])evs[EV2DS17].get(key);					}		else if (d.decksNUM == 6) {			if (h17) return (String[])evs[EV2DH17].get(key);			else return (String[])evs[EV2DS17].get(key);		}		else if (d.decksNUM == 8) {			if (h17) return (String[])evs[EV2DH17].get(key);			else return (String[])evs[EV2DS17].get(key);				}		throw new IllegalStateException("EV getEV unsupported decks number " + d.decksNUM);	}		private String getKey(Hand playersHand,Card dealersUp) {		byte[] b  = new byte[4];		byte vp0 = (byte)playersHand.peekCard(0).getValue();		byte vp1 = (byte)playersHand.peekCard(1).getValue();		byte vd1 = (byte)dealersUp.getValue();		b[3] = vd1;		if (vp0 == 1 || (vp1 != 1 && vp0 > vp1)) {	// if holecard A or > upcard and upcard not A			b[1] = vp0;			b[2] = vp1;		}		else {			b[1] = vp1;			b[2] = vp0;		}		int key = peekInt(b,0);		return new Integer(key).toString();	}		private static final int peekInt(byte [] a, int index)	{		return ((a[index] << 24) | (a[index+1] << 24 >>> 8) | (a[index + 2] << 24 >>> 16) | (a[index + 3] << 24 >>> 24));	}}