package org.bjb;import java.awt.*;import java.awt.event.*;import java.awt.geom.Point2D;import javax.swing.JPanel;import javax.swing.SwingUtilities;class Player implements ActionListener {	boolean human = false;	boolean roundComplete = false;	Hand[] hands = new Hand[4];		// Assumes 4 splits, no playing multiple hands yet	final int[] wagers = new int[4];		// allow different wagers for each hand	Card dealersUp = null;			// To show ev's with PlayerViewer	int balance = 1000;	private int x,y;	int vx,vy;	int currHand = 0;	int currSplit = 0;	int[] splits = new int[1];	// For each of currently max of 1 hand, how many splits?	BalanceViewer bv = null;	Strategy strategy = null;	PlayerViewer viewer = null;	private javax.swing.Timer timer = null;	private boolean split = false;	private boolean active = false;	private boolean insured = false;	private Object TIMER_LOCK = new Object();	private int handsCnt = 0;	private double evs = 0d;	private double ev_avg = 0d;			public Player(Strategy strategy,boolean isHuman,int x,int y,JPanel playingArea) {		this.strategy = strategy;		human = isHuman;		this.x = x;		this.y = y;		final BalanceViewer b_viewer = new BalanceViewer(this,x,y,playingArea);		final Player p = this;		playingArea.addMouseMotionListener(new MouseMotionAdapter() {			public void mouseMoved(MouseEvent evt) {				synchronized(TIMER_LOCK) {					if (b_viewer.contains(new Point2D.Float(evt.getX(),evt.getY()))) {						if (timer == null) {							active = true;							vx = evt.getX();							vy = evt.getY();							timer = new javax.swing.Timer(300,p);							timer.start();						}					}					else {						if (timer != null) {							active = false;							timer.stop();							timer = null;						}					}				}				}		});		this.bv = b_viewer;	}		public void actionPerformed(ActionEvent evt) {		synchronized(TIMER_LOCK) {			if (active) {				active = false;				if (viewer == null) {					viewer = new PlayerViewer(this);					Dimension tmp = Toolkit.getDefaultToolkit().getScreenSize();					if (vx + viewer.getWidth()> (int)tmp.getWidth()) vx = (int)tmp.getWidth() - viewer.getWidth() - 5; 					viewer.setLocation(vx,vy);					viewer.setVisible(true);					timer.stop();					timer = null;				}			}		}	}		public int getX() { return x; }	public int getY() { return y; }	public void setX(int x) { this.x = x; }	public void setY(int y) { this.y = y; }		public int getBalance() { return balance; }	public void setBalance(int balance) { //		new Exception("Player " + toString() + " set balance " + balance).printStackTrace();		this.balance = balance; 		showBalance();	}	public void showBalance() {		SwingUtilities.invokeLater(new Runnable() {			public void run() {				bv.show(balance);			}		});	}	public void setCurrent(boolean current) {		bv.setCurrent(current);/*		if (current) bv.setCurrent(balance);		else showBalance();*/	}		public void show(boolean isDealer, boolean hideFirstCard) {		show(isDealer,hideFirstCard,wagers[currHand]);	}		public void show(boolean isDealer, boolean hideFirstCard, int bet) {		if (split) {			for (int i=0;i<=hands.length;i++)				if (hands[i] == null) break;				else hands[i].showSplit(hideFirstCard,bet,i);		}		else 			hands[currHand].show(isDealer,hideFirstCard,bet);		showBalance();	}		public void setWager(int wager) {		// wager made _before_ round is played out		wagers[currHand] = wager;	}		public int getWager() { return wagers[currHand]; }		public boolean enterWager() {		final Player p = this;		final PlayerWagerEntry entry = new PlayerWagerEntry(p);		try {			javax.swing.SwingUtilities.invokeAndWait(new Runnable() {				public void run() {					try {						entry.setVisible(true);						wagers[currHand] = entry.getWager();					}					catch (Throwable tossed) { tossed.printStackTrace(); }				}			});		}		catch (Throwable tossed) { tossed.printStackTrace(); }		if (wagers[currHand] > 0) return true;		else return false;	}		// TODO use the following two methods to handle on the fly PlayerViewer strategy changes	public int getVisibleCount(Strategy s) {		return 0;	}	 	public void setRoundComplete(boolean complete) {		roundComplete = complete;	}		public String getStrategyName() { return strategy.getName(); }		public Strategy getStrategy() { return strategy; }		public void setStrategy(String strategyName) {		Strategy oldStrategy = strategy;		strategy = Strategy.getStrategy(strategyName);				// TODO initialize new strategy settings from oldStrategy	}		public void closeViewer() { viewer = null; }	public void doubleDown() { wagers[currHand] *= 2; }			public boolean blackjack() { 		if (currHand == 0)			// split hands usually don't count as blackjack			return hands[currHand].blackjack(); 		return false;	}		public boolean busted() { return hands[currHand].busted(); }		public int bestScore() { return hands[currHand].bestScore(); }	public void setHuman(boolean human) { this.human = human; }	public boolean isHuman() { return human; }		public Hand getHand() {		return hands[currHand];	}		public Hand nextHand() { 		switchHand();		return hands[currHand]; 	}		public void addHand(Hand h) {		for (int i=0;i<hands.length;i++) {			if (hands[i] == null) {				hands[i] = h;				wagers[i] = wagers[0];		// init to original value				return;			}		}		throw new IllegalStateException("Player add hand already at max " + hands.length);	}		public boolean hasNextHand() {		// is there a next hand?		if (hands[currHand+1] != null)			return true;		return false;	}		public boolean isSplit() { return split; }		public void splitReset() { currHand = 0; }  // For cycling back through to check result at end		public void addSplit(Hand s) {		updateEVAvg(s,dealersUp);				if (!split) 			hands[0].clearSplit();		// clear background before showing as split		split = true;		splits[currSplit]++;		addHand(s);	}		public void setHand(Hand hand,Card dealersUp) {		updateEVAvg(hand,dealersUp);		split = false;		this.dealersUp = dealersUp;		for (int i=0;i<hands.length;i++) hands[i] = null;		currHand = 0;		currSplit = 0;		for (int i=0;i<splits.length;i++) splits[i] = 0;		hands[currHand] = hand;	}		private void updateEVAvg(Hand hand,Card dealersUp) {		EV ev = new EV();		String[] data = ev.getEV(BlackJackGame.deck,hand,dealersUp,false);		double h_ev = 0d,st = 0d, h = 0d, d = 0d, sp = -99.0d;		try {			st = new Double(data[1]).doubleValue();			h_ev = st;									// init hand ev to stand value			h = new Double(data[2]).doubleValue();			if (h > h_ev) h_ev = h;								d = new Double(data[3]).doubleValue();			if (d > h_ev) h_ev = d;				if (!data[4].trim().startsWith("-"))				sp = new Double(data[4]).doubleValue();			if (sp > h_ev) h_ev = sp;		}		catch (Throwable tossed) { tossed.printStackTrace(); } // bad num somehow?		handsCnt++;		evs += h_ev;		ev_avg = evs/handsCnt;			}		String getAvgEV() { System.out.println("ev_avg="+ev_avg); return new Double(ev_avg).toString(); }		public void switchHand() {		if (currHand == (hands.length - 1)) 			throw new IllegalStateException("Player switch hand already at max 4");		// Is it a split hand or multiple hands?		if (splits[currSplit] > 0)	{	// a split			// currently doesn't matter		}		else { /* currently doesn't matter */ }		currHand++;		if (hands[currHand] == null)			throw new IllegalStateException("Player no hand " + currHand + " to switch to"); 	}		public void addCard(Card c) {		hands[currHand].addCard(c);	}		public void won() {		setBalance(balance + wagers[currHand]);	}		public void lost() {		setBalance(balance - wagers[currHand]);	}	 	public int getBet() { return strategy.getBet(); }		public int getCount() { return strategy.getCount(); }		public void setInsured() {		insured = true;	}		public Card dealersUp() { return dealersUp; }		public void updateCount(Deck d,Card c) {		int before = strategy.getCount();		int before_rc = strategy.getRunningCount();		strategy.updateCount(d,c); //		if (strategy.getName().equals("Hi-Lo"))//			System.out.println("before " + before + " running " + before_rc + " card " + c + " after " + strategy.getCount() + " after running " + strategy.getRunningCount());	}		public float getExpectedValue() {		return 0f;	}		public String updateBasic(Deck d,Hand dealersHand) {		return strategy.updateBasic(strategy.getCount(),d,hands[currHand],dealersHand);	}}