package org.bjb;// Import all the Java API classes needed by this programimport java.io.*;import java.lang.reflect.InvocationTargetException;import java.awt.*;import javax.swing.*;public class BlackJackGame {	// Variable declarations	JTextField decks;	static Deck deck;	static int rounds = 0;	static String elapsedTime;	static long startTime;	Hand currentHand;	Hand playersHand;	Hand dealersHand;	private static final int DELAY_TIME = 850;	private static final int MAX_PLAYERS = 7;//	Hand splitHand;	ImageIcon splitImg = null, soft_doubleImg = null, hard_doubleImg = null, standImg = null;	Preferences preferences = null;	JPanel playingArea;	BufferedReader keyboardInput;	boolean gameOver = false;	boolean dealsup = false;	int decksNUM = 1;	int playersNUM = 1;	int currPlayer = 0;			// Active player if more than one	int gamePlayer = 0;			// default number for human game player	Player[] players = null;	private static final int[] incs = new int[] { 100, 60, 30, -30, -60, -100 };	boolean hideHoleCard = true;	private int dealerBlackjacks = 0;	private int dealerBusts = 0;	boolean wongedOut = false;	final boolean isSimulation;		// Method declarations	public BlackJackGame(Preferences preferences,JTextField decks,JPanel playingArea,boolean isSimulation) {	// Constructor		this.preferences = preferences; 		this.decks = decks;		this.isSimulation = isSimulation;		if (!isSimulation) {			decksNUM = preferences.getDecksNum();			if (decksNUM > 2) hideHoleCard = false;			playersNUM = preferences.getPlayersNum();			deck = new Deck(decksNUM);			keyboardInput = new BufferedReader(new InputStreamReader(System.in));			this.playingArea = playingArea;			// Card w=71 h=96			players = new Player[playersNUM];			players[0] = new Player(new HighLowStrategy(decksNUM),true,5+151*(MAX_PLAYERS-1),90,playingArea);			if (playersNUM > 1) {				int x = 5+151*(MAX_PLAYERS-1), y = 90;				for (int i=1;i<playersNUM;i++) {					x -= 151;					y += incs[i-1]; 					players[i] = new Player(new HighLowStrategy(decksNUM),false,x,y,playingArea);				}			}			startTime = System.currentTimeMillis();		}	}	public Deck getDeck() { return deck; }		public static void updateElapsed() {		long elapsed = System.currentTimeMillis() - startTime;		long hh = elapsed / (1000 * 60 * 60);				long mm = (elapsed / (1000 * 60)) - (hh * 60);		StringBuffer elapsedTime = new StringBuffer();		if (hh > 0) elapsedTime.append(new Long(hh).toString()).append(":");		else elapsedTime.append(":");		if (mm < 10) elapsedTime.append("0");		elapsedTime.append(new Long(mm).toString());		BlackJackGame.elapsedTime = elapsedTime.toString();	}		public static String getElapsed() { return elapsedTime; }	public static int getRounds() { return rounds; }		static Rules getRules() { return Preferences.getRules(); }	public int getDealersBlackjacks() { return dealerBlackjacks; }	public int getDealersBusts() { return dealerBusts; }		public void setDecks(int decks) {				if (decks != decksNUM) {			decksNUM = decks;			if (decksNUM > 2) hideHoleCard = false;			else hideHoleCard = true;			deck = new Deck(decksNUM);		}	}		/**	 * This version of setPlayers is set from simulations	 */	public void setPlayers(Player[] players) {		playersNUM = players.length;		this.players = players;	}		public void setPlayers(int playersNUM,int decksNum) {		setGameOver(true);		updateElapsed();		this.playersNUM = playersNUM;		players = new Player[playersNUM];		players[0] = new Player(Strategy.getStrategy(Preferences.getDefaultStrategy(),decksNum),true,5+151*(MAX_PLAYERS-1),90,playingArea);		if (playersNUM > 1) {			int x = 5+151*(MAX_PLAYERS-1), y = 90;			for (int i=1;i<playersNUM;i++) {				x -= 151;				y += incs[i-1]; 				if (i % 7 == 0)					players[i] = new Player(new HighLowStrategy(decksNum),false,x,y,playingArea);				else if (i % 7 == 1) {					if (Preferences.getDefaultStrategy().equals("Hi-Lo lite"))						players[i] = new Player(new HighLowStrategy(decksNum),false,x,y,playingArea);					else						players[i] = new Player(new HiLoLiteStrategy(decksNum),false,x,y,playingArea);				}				else if (i % 7 == 2) 					players[i] = new Player(new BasicStrategy(decksNum),false,x,y,playingArea);				else if (i % 7 == 3) 					players[i] = new Player(new KOPreferredStrategy(decksNum),false,x,y,playingArea);				else if (i % 7 == 4)					players[i] = new Player(new Red7Strategy(decksNum),false,x,y,playingArea);				else if (i % 7 == 5)					players[i] = new Player(new Illustrious18Strategy(decksNum),false,x,y,playingArea);				else if (i % 7 == 6)					players[i] = new Player(new KORookieStrategy(decksNum),false,x,y,playingArea);				else if (i % 7 == 7)					players[i] = new Player(new Red7EasyStrategy(decksNum),false,x,y,playingArea);			}		}		final SwingWorker worker = new SwingWorker() {			public Object construct() {				initialDeal();				return null;			}		};		worker.start();/*		SwingUtilities.invokeLater(new Runnable() {			public void run() { initialDeal(); }		});*/	}	public void setDealsUp(boolean dealsup) {		if (decksNUM < 3) hideHoleCard = !dealsup;	}		public void setGameOver(boolean over) {		if (!isSimulation && over)			((PlayingArea)playingArea).clearHandMessages();//		if (over)//			new Exception("BJG setGameOver " + over).printStackTrace();		gameOver = over;	}		public boolean isGameOver() { 		return gameOver; 	}		boolean canDouble(int v) {		return (getRules().canDouble(v));					}		boolean canSurrender() { return Preferences.getRules().isSurrender(); }		public void processChart() {		if (isGameOver()) return;		Player p = players[currPlayer];		new ChartSelector(p,deck,dealersHand);	}		/**	 * Return an instance of the named strategy seeded with information from previous 	 * one if provided	 **//*	public static Strategy getStrategy(String name,Strategy previous) {		Strategy s = null;		if (name.equals("Basic Strategy")) 			s = new BasicStrategy();		else if (name.equals("Hi-Lo"))			s = new HighLowStrategy();		// should update strategy count by enumerating players and using		// get visible count method		return s;	}*/	/**	 * update counts for all players except an optional excluded player 	 * for cases like the player already knew his own hole card	 **/	private void updateCounts(Card c,Player exclude) {//		new Exception("update counts " + c + " exclude " + exclude).printStackTrace();		for (int i=0;i<playersNUM;i++) {			if (exclude != null && players[i].equals(exclude)) continue;//			System.out.println("\tupdating " + players[i]);			players[i].updateCount(deck,c);		}	}		boolean hit() {		if (isGameOver()) {			new Exception("Hit on game over").printStackTrace();//			Toolkit.getDefaultToolkit().beep();			return false;		}		Card cd = deck.deal();		players[currPlayer].addCard(cd);		if (!isSimulation)			BlackJackApp.playDrop();		updateCounts(cd,null);				if (players[currPlayer].isHuman())			BlackJackApp.setDoubleEnabled(false);		if (!players[currPlayer].isBusted()) {			if (!isSimulation) {				if (!players[currPlayer].isHuman() && !players[currPlayer].isSplit()) {					try {						SwingUtilities.invokeAndWait(new Runnable() {							public void run() {	//							show(players[currPlayer],false,hideHoleCard);								show(players[currPlayer],false,false);	//							System.out.println("non-split non-human hiliting");					        	GraphicsUtils.hiliteHands((Graphics2D)playingArea.getGraphics(),players[currPlayer],BlackJackApp.teal,PlayingArea.lightGreen);													}						});					}					catch (InvocationTargetException ite) { ite.getTargetException().printStackTrace(); }					catch (InterruptedException iex) { iex.printStackTrace(); }				}				else {					try {						SwingUtilities.invokeAndWait(new Runnable() {							public void run() {								players[currPlayer].show(false,false);								System.out.println("human or split hiliting");					        	GraphicsUtils.hiliteHands(((Graphics2D)playingArea.getGraphics()),players[currPlayer],BlackJackApp.teal,PlayingArea.lightGreen);								BlackJackApp.setDefault(players[currPlayer].updateBasic(deck,dealersHand));							}						});					}					catch (InvocationTargetException ite) { ite.getTargetException().printStackTrace(); }					catch (InterruptedException iex) { iex.printStackTrace(); }				}			}		}		else {	// BUSTED//			System.out.println("BJG player busted " + players[currPlayer].getHand() + " dealer's up " + dealersHand.dealersUp());			players[currPlayer].lost(isSimulation);			players[currPlayer].addBust();			if (!isSimulation) {				BlackJackApp.playPlayerBust();				try {					SwingUtilities.invokeAndWait(new Runnable() {						public void run() {							show(players[currPlayer],false,false);												}					});				}				catch (InvocationTargetException ite) { ite.getTargetException().printStackTrace(); }				catch (InterruptedException iex) { iex.printStackTrace(); }			}			if (hideHoleCard) {				Card hc = players[currPlayer].getHand().peekCard(0);				updateCounts(hc,players[currPlayer]);	// TODO assumes player knew his own card for count so excluded here - verify this.			}			if (players[currPlayer].hasNextHand()) {	// Q. A split hand to play?				players[currPlayer].switchHand();		// Yes - switch to it				if (players[currPlayer].isHuman())					BlackJackApp.setDefault(players[currPlayer].updateBasic(deck,dealersHand));				return true;							// continue player			}			return false;				// switch player		}		return true;			// continue player	}		// TODO add rule to restrict single additional card draw to split aces	// also possibly add rule to restrict to a single aces split, no second resplit	// possible bug, split didn't appear to hit first hand when it should of??????	boolean split() {		if (!playersHand.canSplit()) return false;		// Unsuccessful split		Card c = playersHand.removeCard();		Hand splitHand = new Hand(playingArea,playersHand);		splitHand.addCard(c);		if (!isSimulation)			BlackJackApp.playDrop();		//		updateCounts(c,null);		DOES NOT NEED COUNTING ALREADY WAS	// The hole card pair needs counting				Card players_hole = deck.deal();		playersHand.addCard(players_hole);		if (!isSimulation)			BlackJackApp.playDrop();		updateCounts(players_hole,null);				// dealt up		boolean firstBlackjack = false;		if (players[currPlayer].blackjack()) {			firstBlackjack = true;			if (!isSimulation)				BlackJackApp.playBlackjack();			try {				players[currPlayer].addBlackjack();				players[currPlayer].setWager(players[0].getWager()*3/2);				players[currPlayer].addWin();				players[currPlayer].won(isSimulation);				if (!isSimulation) {					SwingUtilities.invokeAndWait(new Runnable() {						public void run() {							players[currPlayer].show(false,false);							updateElapsed();							}					});				}			}			catch (InvocationTargetException ite) { ite.getTargetException().printStackTrace(); }			catch (InterruptedException iex) { iex.printStackTrace(); }		}//		players[currPlayer].updateCount(deck,players_hole);	// player knows it now		Card split_hole = deck.deal();		splitHand.addCard(split_hole);		players[currPlayer].addSplit(splitHand);		if (!isSimulation && !players[currPlayer].isSplit())			players[currPlayer].getFirstHand().clearSplit();	// clear background before showing as split		if (!isSimulation)			BlackJackApp.playDrop();		updateCounts(split_hole,null);/* Split hand 21's don't count as blackjack is my understanding		if (splitHand.blackjack()) {			if (!isSimulation)				BlackJackApp.playBlackjack();			try {				players[currPlayer].addBlackjack();				players[currPlayer].setWager(players[0].getWager()*3/2);				players[currPlayer].addWin();				players[currPlayer].won(isSimulation);				if (!isSimulation) {					SwingUtilities.invokeAndWait(new Runnable() {						public void run() {							players[currPlayer].show(false,false);							updateElapsed();													}					});				}			}			catch (InvocationTargetException ite) { ite.getTargetException().printStackTrace(); }			catch (InterruptedException iex) { iex.printStackTrace(); }			if (firstBlackjack) return false;		}*/		if (firstBlackjack)			players[currPlayer].switchHand();					//		players[currPlayer].updateCount(deck,split_hole);	// knows this too		if (!isSimulation) {			try {				SwingUtilities.invokeAndWait(new Runnable() {					public void run() {						show(players[currPlayer],false,false);										}				});			}			catch (InvocationTargetException ite) { ite.getTargetException().printStackTrace(); }			catch (InterruptedException iex) { iex.printStackTrace(); }		}		if (playersHand.peekCard(0).iValue == 1) return false;		if (players[currPlayer].isHuman())			BlackJackApp.setDefault(players[currPlayer].updateBasic(deck,dealersHand));		return true;	}		boolean doubleDown() {		Hand h = players[currPlayer].getHand();		int v = h.bestScore();		if (!getRules().canDouble(v)) {			// TODO support 9-10-11 variation??? 			throw new IllegalStateException("double down against rules");//			Toolkit.getDefaultToolkit().beep();			//			return true;		}		if (!h.canDoubleDown()) {			if (true)				throw new IllegalStateException("double down not allowed");//			System.out.println("double down not allowed");//			Toolkit.getDefaultToolkit().beep();			//			return true;		}		Card cd = deck.deal();		players[currPlayer].addCard(cd);		if (!isSimulation)			BlackJackApp.playDrop();		updateCounts(cd,null);		players[currPlayer].doubleDown();		if (!isSimulation) {			try {				SwingUtilities.invokeAndWait(new Runnable() {					public void run() {						players[currPlayer].show(false,false);									}				});			}			catch (InvocationTargetException ite) { ite.getTargetException().printStackTrace(); }			catch (InterruptedException iex) { iex.printStackTrace(); }		}		return stand();				// let stand handle mulitple hand check (only splits currently)	}			boolean insure() {		players[currPlayer].setInsured();		return false;	}		boolean stand() {		if (players[currPlayer].hasNextHand()) {			players[currPlayer].switchHand();			if (players[currPlayer].isHuman())				BlackJackApp.setDefault(players[currPlayer].updateBasic(deck,dealersHand));			return true;			// continue player		}		return false;				// switch player	}		void initialDeal() {		BlackJackApp.guiDisable();		setGameOver(false);		deck.checkShuffle();		boolean shuffled = false;		if (deck.isShuffled()) {			shuffled = true;			if (!isSimulation) {				try {					SwingUtilities.invokeAndWait(new Runnable() {						public void run() {							BlackJackApp.playShuffle();							((PlayingArea)playingArea).displayShuffled();												}					});				}				catch (InvocationTargetException ite) { ite.getTargetException().printStackTrace(); }				catch (InterruptedException iex) { iex.printStackTrace(); }			}//			EffectsLocker.acquire();		}		if (!isSimulation)			System.out.println("BJG shuffle should wait");//		synchronized(BlackJackApp.EFFECT_LOCK) {//			setGameOver(false);//		}		if (!isSimulation)			System.out.println("BJG after shuffle wait");		if (!isSimulation)			updateElapsed();		rounds++;		// set the wagers before we show any hands		for (int i=0;i<playersNUM;i++) {			if (shuffled) {				players[i].getStrategy().reset();			}			if (players[i].isHuman()) {				try {					System.out.println("splashLogo on player " + i);					BlackJackApp.splashLogo();					if (!isWongedOut(players[i])) {						if (!players[i].enterWager()) {							players[i].setWager(players[i].getBet());						}					}					System.out.println("BJG after wager stuff should clear logo");					((PlayingArea)playingArea).clear();					BlackJackApp.clearLogo();				}				catch (Exception ex) { ex.printStackTrace(); }			}			else 				players[i].setWager(players[i].getBet());		}		playersHand = new Hand(playingArea,5+151*(MAX_PLAYERS-1),90);		currentHand = playersHand;//		splitHand = null;		dealersHand = new Hand(playingArea);		for (int i=0; i<2; i++) {			Card c = deck.deal();			currentHand.addCard(c);			if (!isSimulation) {				if (i == 0)					BlackJackApp.playDraw();				else 					BlackJackApp.playDrop();			}			if (players[0].isHuman() && i == 0 && hideHoleCard) 				players[0].updateCount(deck,c);			else if (players[0].isHuman() && i == 0)				updateCounts(c,null);			else if (i != 0)				updateCounts(c,null);			Card dc = deck.deal();			dealersHand.addCard(dc);			if (!isSimulation) {				if (i == 0)					BlackJackApp.playDraw();				else 					BlackJackApp.playDrop();			}			if (i != 0)				updateCounts(dc,null);		}		int d_up = dealersHand.dealersUp();		if (!isSimulation) {			if (d_up > 1 && d_up < 7) {				// message dealers hand shows weakness				((PlayingArea)playingArea).addHandMessage("The dealers hand shows weakness.");			}			else if (d_up > 9) {				// message dealers hand shows strength				((PlayingArea)playingArea).addHandMessage("The dealers hand shows strength");			}	//		java.awt.Point pscr = playingArea.getLocationOnScreen();			try {				SwingUtilities.invokeAndWait(new Runnable() {					public void run() {						dealersHand.show(true,true);									}				});			}			catch (InvocationTargetException ite) { ite.getTargetException().printStackTrace(); }			catch (InterruptedException iex) { iex.printStackTrace(); }		}				players[0].setHand(currentHand,dealersHand.peekCard(1));		if (!isSimulation)			players[0].setCurrent(true);			// flash the current player		if (players[0].isHuman()) {			if (!players[0].canDoubleDown())				BlackJackApp.setDoubleEnabled(false);			if (!players[0].canSplit())				BlackJackApp.setSplitEnabled(false);			try {				SwingUtilities.invokeAndWait(new Runnable() {					public void run() {						show(players[0],false,false);					}				});			}			catch (InvocationTargetException ite) { ite.getTargetException().printStackTrace(); }			catch (InterruptedException iex) { iex.printStackTrace(); }			String strategyName = players[0].getStrategyName();			if (strategyName.equals("Hi-Lo") || strategyName.equals("Hi-Lo lite"))				((PlayingArea)playingArea).addHandMessage(strategyName + " is a balanced, level-1 card counting system.");			else if (strategyName.equals("K-O Rookie"))				((PlayingArea)playingArea).addHandMessage("K-O Rookie is a unbalanced, level-1 card counting system.");			else if (strategyName.equals("K-O Preferred"))				((PlayingArea)playingArea).addHandMessage("K-O Preferred is a unbalanced, level-1 card count system.");						}		else if (!isSimulation) {			try {				SwingUtilities.invokeAndWait(new Runnable() {					public void run() {						show(players[0],false,hideHoleCard);											}				});			}			catch (InvocationTargetException ite) { ite.getTargetException().printStackTrace(); }			catch (InterruptedException iex) { iex.printStackTrace(); }		}		if (playersNUM > 1) {			int x = 5+151*(MAX_PLAYERS-1), y = 90;			for (int i=1;i<playersNUM;i++) {				x -= 151;				y += incs[i-1]; 				Hand h = new Hand(playingArea,x,y);				for (int j=0; j<2; j++) {					Card c = deck.deal();					h.addCard(c);					if (!isSimulation) {						if (i == 0)							BlackJackApp.playDraw();						else 							BlackJackApp.playDrop();					}					if (j == 0 && hideHoleCard) 						players[i].updateCount(deck,c);					else updateCounts(c,null);				}				players[i].setHand(h,dealersHand.peekCard(1));				final Player p = players[i];				if (p.isHuman()) 					try {						SwingUtilities.invokeAndWait(new Runnable() {							public void run() {								show(p,false,false);												}						});					}					catch (InvocationTargetException ite) { ite.getTargetException().printStackTrace(); }					catch (InterruptedException iex) { iex.printStackTrace(); }				else if (!isSimulation) {					try {						SwingUtilities.invokeAndWait(new Runnable() {							public void run() {								show(p,false,hideHoleCard);														}						});					}					catch (InvocationTargetException ite) { ite.getTargetException().printStackTrace(); }					catch (InterruptedException iex) { iex.printStackTrace(); }				}			}		}				// Do a round to check for insurance		if (dealersHand.peekCard(1).getValue() == 1) {					for (int i=0;i<playersNUM;i++) {				if (players[i].isHuman()) {					JOptionPane pane = new JOptionPane(					"<html>"+					"<head>"+					"<style type=\"text/css\">"+					"b { font: 14pt \"Lucida Grande\" }"+					"p { font: 12pt \"Lucida Grande\"; margin-top: 8px }"+					"</style>"+					"</head>"+					"<b>Insurance?</b><p>"+					"The dealer is showing a ace.<br>"+					"Do you want to take insurance?",					JOptionPane.WARNING_MESSAGE					);					Object[] options = { "Yes", "No" };					pane.setOptions(options);					pane.setInitialValue(options[1]);					JDialog dialog = pane.createDialog(new JFrame(""), "Warning: Dealer Ace up card");					dialog.setVisible(true);					String s = (String)pane.getValue();					if (s != null && s.equals("Yes")) 						players[i].setInsured();				}				else {/*					String option = players[i].updateBasic(deck,dealersHand);					if (option.equals("Insurance"))*/					if (players[i].getStrategy().insure(deck))						players[i].setInsured();				}			}		}		// Check for initial blackjacks		if (players[0].blackjack() && !dealersHand.blackjack()) {			if (!isSimulation)				BlackJackApp.playBlackjack();			players[0].addBlackjack();			players[0].setWager(players[0].getWager()*3/2);			players[0].addWin();			players[0].won(isSimulation);			if (!isSimulation) {				try {					SwingUtilities.invokeAndWait(new Runnable() {						public void run() {							show(players[0],false,false);												}					});				}				catch (InvocationTargetException ite) { ite.getTargetException().printStackTrace(); }				catch (InterruptedException iex) { iex.printStackTrace(); }				updateElapsed();			}			if (playersNUM > 1) 					nextPlayer();			else setGameOver(true);			if (!isSimulation)				BlackJackApp.playBtnReset();			return;		}		else if (dealersHand.blackjack()) {		// Dealer natural?			dealerBlackjacks++;			if (!isSimulation)				BlackJackApp.playDealerBJ();			Card dc = dealersHand.peekCard(0);			updateCounts(dc,null);			if (!isSimulation) {				try {					SwingUtilities.invokeAndWait(new Runnable() {						public void run() {							dealersHand.show(true,false);											}					});				}				catch (InvocationTargetException ite) { ite.printStackTrace(); }				catch (InterruptedException iex) { iex.printStackTrace(); }			}			for (int i=0;i<playersNUM;i++) {	// everybody loses unless they also have natural				Card c = players[i].getHand().peekCard(0);				if (i > 0 && hideHoleCard)		// Don't double count our, player[0], hole card					updateCounts(c,null);	    // update everybody for hole card if it was hidden and not already counted too				if (players[i].blackjack()) {					players[i].addPush();					players[i].pushed();			// updated total wagered					continue;		// a push so just skip				}				players[i].addLoss();				players[i].lost(isSimulation);				if (!isSimulation) {					final Player p = players[i];					try {						SwingUtilities.invokeAndWait(new Runnable() {							public void run() {								show(p,false,false);														}						});					}					catch (InvocationTargetException ite) { ite.getTargetException().printStackTrace(); }					catch (InterruptedException iex) { iex.printStackTrace(); }				}			}			setGameOver(true);			if (!isSimulation) {				BlackJackApp.playBtnReset();				updateElapsed();			}		}/*		else if (dealersHand.peekCard(1).getValue() == 1) {		// Do a round checking for insurance results			for (int i=0;i<playersNUM;i++) {	// everybody loses unless they also have natural				Card c = players[i].getHand().peekCard(0);				updateCounts(c,null);			// update everybody for hole card				if (players[i].blackjack()) continue;		// a push so just skip				players[i].lostInsurance();				players[i].show(false,false);			}					}*/		else if (players[currPlayer].isHuman()) {			BlackJackApp.setDefault(players[currPlayer].updateBasic(deck,dealersHand));		}		else {			autoPlay(players[currPlayer]);			nextPlayer();		}		if (!isSimulation)			BlackJackApp.guiEnable(players[currPlayer].canDoubleDown(),players[currPlayer].canSplit());	}		public void setWongedOut(boolean wongedOut) {		this.wongedOut = wongedOut;	}	private boolean isWongedOut(Player p) {		if (true) return false;		// player selected wonged out overrides preferences//		if (wongedOut) return true;		// now check if preferences wongs out this player//		if (Preferences.isWongingEnabled())//			return Preferences.isWongedOut(p);		return false;	}		void nextPlayer() {		if (!isSimulation)			BlackJackApp.guiDisable();		while (currPlayer != (playersNUM - 1)) {			if (!isSimulation)				players[currPlayer].setCurrent(false);		// reset possible flash on prior			currPlayer++;			if (!isSimulation)				players[currPlayer].setCurrent(true);		// flash the new current player			if (players[currPlayer].isHuman()) {				try {					SwingUtilities.invokeAndWait(new Runnable() {						public void run() {							show(players[currPlayer],false,false);													}					});				}				catch (InvocationTargetException ite) { ite.printStackTrace(); }				catch (InterruptedException iex) { iex.printStackTrace(); }				BlackJackApp.setDefault(players[currPlayer].updateBasic(deck,dealersHand));				BlackJackApp.guiEnable(players[currPlayer].canDoubleDown(),players[currPlayer].canSplit());				return;			// Let the man play			}			else {				if (!isSimulation) {					try {						SwingUtilities.invokeAndWait(new Runnable() {							public void run() {//								show(players[currPlayer],false,hideHoleCard);									show(players[currPlayer],false,false);														}						});					}					catch (InvocationTargetException ite) { ite.getTargetException().printStackTrace(); }					catch (InterruptedException iex) { iex.printStackTrace(); }				}				autoPlay(players[currPlayer]);			}		}		// Need to verify not all player hands busted or were blackjack TODO		boolean activePlayers = false;		for (int i=0;i<playersNUM;i++) {			if (players[i].isSplit()) {			// Make sure we start on the 1st hand				players[i].splitReset();			}			if (!players[i].isBusted() && !players[i].blackjack()) {				activePlayers = true;				break;			} 			boolean activeSplit = false;			while (players[i].hasNextHand()) {				Hand h = players[i].nextHand();				if (!(h.isBusted())) {					activeSplit = true;					break;				}			}			if (activeSplit) {				activePlayers = true;				break;			}		}		if (activePlayers && dealersHand.mustHit()) 			while (dealersHand.mustHit()) {				Card dc = deck.deal();				dealersHand.addCard(dc);				if (!isSimulation)					BlackJackApp.playDrop();				updateCounts(dc,null);				if (!isSimulation) {					try {						SwingUtilities.invokeAndWait(new Runnable() {							public void run() {								dealersHand.show(true,false);												}						});					}					catch (InvocationTargetException ite) { ite.getTargetException().printStackTrace(); }					catch (InterruptedException iex) { iex.printStackTrace(); }				}			}		else if (!isSimulation) try {			SwingUtilities.invokeAndWait(new Runnable() {				public void run() {					dealersHand.show(true,false);								}			});		}		catch (InvocationTargetException ite) { ite.getTargetException().printStackTrace(); }		catch (InterruptedException iex) { iex.printStackTrace(); }		// Done somehow update counts for dealers hole card		Card dc = dealersHand.peekCard(0);		updateCounts(dc,null);				// TODO verify nextplayers are getting payed for blackjack??? autoplay does, but subsequent human players????		if (dealersHand.isBusted()) {					// TODO need to check counts in here????			dealerBusts++;			if (!isSimulation)				BlackJackApp.playDealerBust();			for (int i=0;i<playersNUM;i++) {				if (players[i].isSplit())					players[i].splitReset();				if (!(players[i].isBusted() || players[i].blackjack())) {					players[i].won(isSimulation);					if (!players[i].isSplit() && hideHoleCard) {		// Not already counted for bust or bj & not split, count hole card now						Card hc = players[i].getHand().peekCard(0);						updateCounts(hc,players[i]);										}				}				while (players[i].hasNextHand()) {					Hand h = players[i].nextHand();					if (!(h.isBusted()))						players[i].won(isSimulation);				}				if (!isSimulation) {					final Player p = players[i];					try {						SwingUtilities.invokeAndWait(new Runnable() {							public void run() {								show(p,false,false);														}						});					}					catch (InvocationTargetException ite) { ite.getTargetException().printStackTrace(); }					catch (InterruptedException iex) { iex.printStackTrace(); }				}			}			if (!isSimulation)				System.out.println("players done");		}		else if (activePlayers) for (int i=0;i<playersNUM;i++) {		// TODO counts? split hands????			if (players[i].isSplit())			// Make sure we start on the 1st hand				players[i].splitReset();			if (!(players[i].isBusted() || players[i].blackjack())) {				if (!players[i].isSplit()) {			// Not already counted for bust or bj & not split, count hole card now					Card hc = players[i].getHand().peekCard(0);					if (hideHoleCard)						updateCounts(hc,players[i]);				}				if (dealersHand.bestScore() > players[i].bestScore()) {					players[i].lost(isSimulation);								}				else if (dealersHand.bestScore() < players[i].bestScore())					players[i].won(isSimulation);				else players[i].pushed();		// update total wagered				while (players[i].hasNextHand()) {					Hand h = players[i].nextHand();					if (!h.isBusted()) {						if (dealersHand.bestScore() > h.bestScore())							players[i].lost(isSimulation);						else if (dealersHand.bestScore() < h.bestScore())							players[i].won(isSimulation);						else players[i].pushed();					}				}			}			if (!isSimulation) try {				final Player p = players[i];				SwingUtilities.invokeAndWait(new Runnable() {					public void run() {						show(p,false,false);										}				});			}			catch (InvocationTargetException ite) { ite.getTargetException().printStackTrace(); }			catch (InterruptedException iex) { iex.printStackTrace(); }		}		currPlayer = 0;		setGameOver(true);		if (!isSimulation) {			try {				SwingUtilities.invokeAndWait(new Runnable() {					public void run() {						updateElapsed();						BlackJackApp.setDefault("Play");						BlackJackApp.guiEnable(true,true);					}				});			}			catch (InvocationTargetException ite) { ite.printStackTrace(); }			catch (InterruptedException iex) { iex.printStackTrace(); }		}	}		private static void show(final Player p,final boolean isDealer,final boolean hideFirstCard) {		if (!SwingUtilities.isEventDispatchThread())			throw new IllegalStateException("BlackJackGame show not on event dispatch thread");		p.show(isDealer, hideFirstCard);	}		public synchronized void delay(int ms) {		try { wait(ms); }		catch (InterruptedException iex) {}	}		void autoPlay(Player p) {		playersHand = players[currPlayer].getHand();		currentHand = playersHand;		if (players[currPlayer].blackjack()) {			if (!isSimulation) {				BlackJackApp.playBlackjack();				delay(DELAY_TIME);				}			if (hideHoleCard) {				Card pc = playersHand.peekCard(0);		// Make sure we count the hole card				updateCounts(pc,null);			}			players[currPlayer].addBlackjack();			players[currPlayer].setWager(players[currPlayer].getWager()*3/2);					players[currPlayer].addWin();			players[currPlayer].won(isSimulation);			if (!isSimulation) {				try {					SwingUtilities.invokeAndWait(new Runnable() {						public void run() {							show(players[currPlayer],false,false);												}					});				}				catch (InvocationTargetException ite) { ite.printStackTrace(); }				catch (InterruptedException iex) { iex.printStackTrace(); }			}			return;		}		String strategy = players[currPlayer].updateBasic(deck,dealersHand);		boolean done = false;		while (!done) {			if (strategy.equals("Split")) {				if (!isSimulation)					delay(DELAY_TIME);				if (!split()) {					done = true;					continue;				}//				if (players[currPlayer].hasNextHand())//					players[currPlayer].switchHand();//				else {//					done = true;			// TODO - get rid of this when split debugged//					continue;//				}			}			else if (strategy.equals("Double down")) {				if (!isSimulation)					delay(DELAY_TIME);				if (!doubleDown()) {		// true indicates continue with current players next hand					done = true;					continue;				}			}			else if (strategy.equals("Stand")) {				if (!isSimulation)					delay(DELAY_TIME);				if (!stand()) {				// true indicates continue with current players next hand					done = true;					continue;				}			}			else {				if (!isSimulation)					delay(DELAY_TIME);				if (!hit()) {		// true indicates continue with current players next hand					done = true;					continue;				}			}			strategy = players[currPlayer].updateBasic(deck,dealersHand);		}		updateElapsed();	}/*		void tie() {		players[currPlayer].setCurrent(false);			// reset possible prior flash		if (playersNUM > 1) {			if (currPlayer == (playersNUM - 1)) {				currPlayer = 0;				updateElapsed();				setGameOver(true);				return;			}			else currPlayer++;			players[currPlayer].setCurrent(true);		// flash the new current player			if (!players[currPlayer].isHuman()) 				autoPlay(players[currPlayer]);		}		updateElapsed();		setGameOver(true);	}*/	void showBalances() {		for (int i=0;i<playersNUM;i++)			players[i].showBalance();					}		void incorrect() {		SwingUtilities.invokeLater(new Runnable() {			public void run() {				players[currPlayer].flashIncorrect();													}		});	}		void showChart() {//		ImageIcon ico = null;/*		if (basicStrategy.getText().equals("Split")) {			if (splitImg == null)				splitImg = Card.getIcon("images/pair_splitting.jpg");			ico = splitImg;		}		else if (basicStrategy.getText().equals("Double down")) {			if (currentHand.isSoft()) {				if (soft_doubleImg == null)					soft_doubleImg = Card.getIcon("images/soft_doubling.jpg");				ico = soft_doubleImg;			}			else {				if (hard_doubleImg == null)					hard_doubleImg = Card.getIcon("images/hard_doubling.jpg");				ico = hard_doubleImg;			}		}		else {			if (standImg == null)				standImg = Card.getIcon("images/standing.jpg");			ico = standImg;		}		ChartViewer viewer = new ChartViewer(ico);		viewer.setVisible(true);*/	}	}	// End of BlackJackGame class