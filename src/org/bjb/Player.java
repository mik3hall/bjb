package org.bjb;import java.awt.*;import java.awt.event.*;import java.awt.geom.Point2D;import javax.swing.JPanel;class Player implements ActionListener {	boolean human = false;	boolean roundComplete = false;	Hand[] hands = new Hand[4];		// Assumes 4 splits, no playing multiple hands yet	final int[] wagers = new int[4];		// allow different wagers for each hand	Card dealersUp = null;			// To show ev's with PlayerViewer	int balance = Preferences.getBankRoll();	private int x,y;	int vx,vy;	int currHand = 0;	int currSplit = 0;	int[] splits = new int[1];	// For each of currently max of 1 hand, how many splits?	BalanceViewer bv = null;	private Strategy strategy = null;	PlayerViewer viewer = null;	private javax.swing.Timer timer = null;	private boolean split = false;	private boolean active = false;	private boolean insured = false;	private boolean playing = true;		// not playing if wonged out	private Object TIMER_LOCK = new Object();	private int handsCnt = 0;	private double evs = 0d;	private double ev_avg = 0d;	private int totalWagered = 0;	private int blackjacks = 0;	private int wins = 0;	private int losses = 0;	private int pushes = 0;	private int busts = 0;	private int surrenders = 0;	private int doubles = 0;	private int splitsNum = 0;		public Player(Strategy strategy,boolean isHuman,int x,int y,JPanel playingArea) {		if (strategy == null)			throw new IllegalArgumentException("Player with null strategy");		this.strategy = strategy;		human = isHuman;		this.x = x;		this.y = y;		final BalanceViewer b_viewer = new BalanceViewer(this,x,y,playingArea);		final Player p = this;		playingArea.addMouseMotionListener(new MouseMotionAdapter() {			public void mouseMoved(MouseEvent evt) {				synchronized(TIMER_LOCK) {					if (b_viewer.contains(new Point2D.Float(evt.getX(),evt.getY()))) {						if (timer == null) {							active = true;							vx = evt.getX();							vy = evt.getY();							timer = new javax.swing.Timer(300,p);							timer.start();						}					}					else {						if (timer != null) {							active = false;							timer.stop();							timer = null;						}					}				}				}		});		this.bv = b_viewer;	}		public void reset(int balance) {		this.balance = balance;		evs = 0d;		ev_avg = 0d;		totalWagered = 0;		blackjacks = 0;		wins = 0;		losses = 0;		pushes = 0;		busts = 0;		surrenders = 0;		doubles = 0;		splitsNum = 0;	}		public void actionPerformed(ActionEvent evt) {		synchronized(TIMER_LOCK) {			if (active) {				active = false;				if (viewer == null) {					viewer = new PlayerViewer(this);					Dimension tmp = Toolkit.getDefaultToolkit().getScreenSize();					if (vx + viewer.getWidth()> (int)tmp.getWidth()) vx = (int)tmp.getWidth() - viewer.getWidth() - 5; 					viewer.setLocation(vx,vy);					viewer.setVisible(true);					timer.stop();					timer = null;				}			}		}	}		public int getX() { return x; }	public int getY() { return y; }	public void setX(int x) { this.x = x; }	public void setY(int y) { this.y = y; }		public int getBalance() { return balance; }	public void setBalance(int balance,boolean isSimulation) { //		new Exception("Player " + toString() + " set balance " + balance).printStackTrace();		this.balance = balance; 		if (!isSimulation)			showBalance();	}	public void showBalance() {		bv.show(balance);	}		public void setCurrent(boolean current) {		bv.setCurrent(current);/*		if (current) bv.setCurrent(balance);		else showBalance();*/	}		public void show(boolean isDealer, boolean hideFirstCard) {		show(isDealer,hideFirstCard,wagers[currHand]);	}		public void show(boolean isDealer, boolean hideFirstCard, int bet) {		if (!playing) {			showWongedOut();			return;		}		if (split) {			for (int i=0;i<hands.length;i++)				if (hands[i] == null) break;				else hands[i].showSplit(hideFirstCard,bet,i);		}		else 			hands[currHand].show(isDealer,hideFirstCard,bet);		showBalance();	}		public void setPlaying(boolean playing) {		this.playing = playing;	}		public boolean isPlaying() {		checkWongStatus();		return playing;	}		private void checkWongStatus() {			}		private void showWongedOut() {		bv.showWongedOut();	}		public void setWager(int wager) {		// wager made _before_ round is played out		wagers[currHand] = wager;	}		public int getWager() { return wagers[currHand]; }		public boolean enterWager() {		final Player p = this;		final PlayerWagerEntry entry = new PlayerWagerEntry(p);		try {			javax.swing.SwingUtilities.invokeAndWait(new Runnable() {				public void run() {					try {						entry.setVisible(true);						wagers[currHand] = entry.getWager();					}					catch (Throwable tossed) { tossed.printStackTrace(); }				}			});		}		catch (Throwable tossed) { tossed.printStackTrace(); }		if (wagers[currHand] > 0) return true;		else return false;	}		// TODO use the following two methods to handle on the fly PlayerViewer strategy changes	public int getVisibleCount(Strategy s) {		return 0;	}	 	public void setRoundComplete(boolean complete) {		roundComplete = complete;	}		public String getStrategyName() { 		return strategy.getName(); 	}		public String getBettingName() { return strategy.getBetting(); }		public Strategy getStrategy() { return strategy; }		public void setStrategy(String strategyName,int decksNum) {//		Strategy oldStrategy = strategy;		strategy = Strategy.getStrategy(strategyName,decksNum);		// TODO initialize new strategy settings from oldStrategy	}		public void closeViewer() { viewer = null; }	public void doubleDown() { wagers[currHand] *= 2; }			public boolean blackjack() { 		if (!isSplit())			// split hands usually don't count as blackjack			return hands[currHand].blackjack(); 		return false;	}		public boolean isBusted() { return hands[currHand].isBusted(); }		public int bestScore() { return hands[currHand].bestScore(); }	public void setHuman(boolean human) { this.human = human; }	public boolean isHuman() { return human; }	public Hand getFirstHand() {		return hands[0];	}		public Hand getHand() {		return hands[currHand];	}		public Hand nextHand() { 		switchHand();		return hands[currHand]; 	}		public void addHand(Hand h) {		boolean splittable = true;		for (int i=0;i<hands.length;i++) {			if (hands[i] == null) {				hands[i] = h;				wagers[i] = wagers[0];		// init to original value				if (i == hands.length-1) {					splittable = false;					break;				}			}		}		if (!splittable) {			for (int i=0;i<hands.length;i++) {				hands[i].setSplitable(false);			}			return;		}		throw new IllegalStateException("Player add hand already at max " + hands.length);	}		public boolean hasNextHand() {		// is there a next hand?		if (hands.length > currHand+1 && hands[currHand+1] != null)			return true;		return false;	}		public boolean isSplit() { return split; }		public void splitReset() { currHand = 0; }  // For cycling back through to check result at end		public void addSplit(Hand s) {		//		if (!split) //			hands[0].clearSplit();		// clear background before showing as split		split = true;		splits[currSplit]++;		addHand(s);	}		public void setHand(Hand hand,Card dealersUp) {		updateEVAvg(hand,dealersUp);		split = false;		this.dealersUp = dealersUp;		for (int i=0;i<hands.length;i++) hands[i] = null;		currHand = 0;		currSplit = 0;		for (int i=0;i<splits.length;i++) splits[i] = 0;		hands[currHand] = hand;	}		private void updateEVAvg(Hand hand,Card dealersUp) {		EV ev = new EV();		String[] data = ev.getEV(BlackJackGame.deck,hand,dealersUp,false);		double h_ev = 0d,st = 0d, h = 0d, d = 0d, sp = -99.0d;		try {			st = new Double(data[1]).doubleValue();			h_ev = st;									// init hand ev to stand value			h = new Double(data[2]).doubleValue();			if (h > h_ev) h_ev = h;								d = new Double(data[3]).doubleValue();			if (d > h_ev) h_ev = d;				if (!data[4].trim().startsWith("-"))				sp = new Double(data[4]).doubleValue();			if (sp > h_ev) h_ev = sp;		}		catch (Throwable tossed) { tossed.printStackTrace(); } // bad num somehow?		handsCnt++;		evs += h_ev;		ev_avg = evs/handsCnt;			}		String getAvgEV() { /* System.out.println("ev_avg="+ev_avg); */ return new Double(ev_avg).toString(); }		public void switchHand() {		if (currHand == (hands.length - 1)) 			throw new IllegalStateException("Player switch hand already at max 4");		// Is it a split hand or multiple hands?		if (splits[currSplit] > 0)	{	// a split			// currently doesn't matter		}		else { /* currently doesn't matter */ }		currHand++;		if (hands[currHand] == null)			throw new IllegalStateException("Player no hand " + currHand + " to switch to"); //		System.out.println("Player switch hand to " + hands[currHand]);		updateEVAvg(hands[currHand],dealersUp);			}		public void addCard(Card c) {		hands[currHand].addCard(c);	}		public boolean canDoubleDown() {		int v = bestScore();		if (!Preferences.getRules().canDouble(v)) 						return false;		return hands[currHand].canDoubleDown();	}		public boolean canSplit() {		return hands[currHand].canSplit();	}		public void won(boolean isSimulation) {		wins++;		totalWagered += wagers[currHand];		setBalance(balance + wagers[currHand],isSimulation);	}		public void lost(boolean isSimulation) {		losses++;		totalWagered += wagers[currHand];		setBalance(balance - wagers[currHand],isSimulation);	}	 	public void pushed() {		pushes++;		totalWagered += wagers[currHand];	}		public int getBet() { return strategy.getBet(); }		public int getCount() { return strategy.getCount(); }		public int getTotalWagered() { return totalWagered; }	public void addBlackjack() { blackjacks++; }	public int getBlackjacks() { return blackjacks; }	public void addWin() { wins++; }	public int getWins() { return wins; }	public void addLoss() { losses++; }	public int getLosses() { return losses; }	public void addPush() { pushes++; }	public int getPushes() { return pushes; }	public void addSurrender() { surrenders++; }	public int getSurrenders() { return surrenders; }	public void addDouble() { doubles++; }	public int getDoubles() { return doubles; }	public void addSplit() { splitsNum++; }	public int getSplits() { return splitsNum; }	public void addBust() { busts++; }	public int getBusts() { 		return busts; 	}		public String toString() {		StringBuilder sb = new StringBuilder("Player: ");		sb.append(strategy.getName());		sb.append(" ");		sb.append(new Integer(getBalance()).toString());		return sb.toString();	}		public void setInsured() {		insured = true;	}		public Card dealersUp() { return dealersUp; }		public void updateCount(Deck d,Card c) {//		int before = strategy.getCount();//		int before_rc = strategy.getRunningCount();		strategy.updateCount(d,c); //		if (strategy.getName().equals("Hi-Lo"))//			System.out.println("before " + before + " running " + before_rc + " card " + c + " after " + strategy.getCount() + " after running " + strategy.getRunningCount());	}		public float getExpectedValue() {		return 0f;	}		public String updateBasic(Deck d,Hand dealersHand) {//		if (isSplit())//			System.out.println("Player: split update basic for hand " + currHand + " " + hands[currHand] + " getting " + strategy.updateBasic(strategy.getCount(),d,hands[currHand],dealersHand));		return strategy.updateBasic(d,hands[currHand],dealersHand);//		String s = strategy.updateBasic(d,hands[currHand],dealersHand);//		System.out.println("Player updateBasic returning " + s);//		return s;	}		public void flashIncorrect() {		bv.flashIncorrect();	}}